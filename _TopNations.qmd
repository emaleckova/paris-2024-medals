## COL: National team sizes

```{r}
#| label: prepare-team-sizes

team_sizes <- athletes_dat |> 
  group_by(country_long, country_code) |> 
  summarize(n_participants = n())
```

### {.tabset}

```{r}
#| label: plot-team-sizes

# AIM: Prepare by country participants as well as a simplified version with all European countries grouped

# Prepare world map (credits: https://r-graph-gallery.com/web-dorling-cartogram-with-R.html)
world <- ne_countries(scale = 110, type = "countries", returnclass = "sf") |> 
  # Convert WGS84 to projected crs (here Robinson)
  st_transform(world_ne, crs = "ESRI:54030")

# Merge with teams sizes
# Two column combination are used to cover more cases
map_teams <- team_sizes |> 
  left_join(select(world, iso_a2, iso_a3, name_long), by = c("country_code" = "iso_a3"))

map_teams <- map_teams |> 
  left_join(select(world, iso_a2, name_long), by = c("country_long" = "name_long"), suffix = c("", "_alt"))

# Use coalesce to fill in missing values from the second join
map_teams <- map_teams |> 
  # sometimes only one of the geometries contains actual data - keep this one
  mutate(
    iso_a2 = coalesce(iso_a2, iso_a2_alt),
    geometry = if_else(st_is_empty(geometry), geometry_alt, geometry)
  ) |> 
  select(-iso_a2_alt, -geometry_alt) |> 
  drop_na(n_participants) |> 
  filter(!st_is_empty(geometry)) |>  # filter out empty geometries
  # include continent
  left_join(select(world, iso_a2, continent)) |> 
   # conversion after merging - needed by "dorling"
  st_as_sf()

### Group European countries

# Europe has a lot of countries with strong participation.
# For the world overview, group all European countries

eu_grouped <- map_teams |> 
  filter(continent == "Europe") |> 
  group_by(continent) |> 
  summarize(n_participants = sum(n_participants)) |> 
  mutate(country_long = "Europe",
         country_code = "Europe",
         name_long = "European countries",
         iso_a2 = NA,
         geometry = map_teams[map_teams$country_code == "CZE", ]$geometry)

map_teams_eu_grouped <- rbind.data.frame(filter(map_teams, continent != "Europe"), eu_grouped)
map_teams_eu_grouped <- map_teams_eu_grouped |> 
  st_as_sf()
```

#### World

```{r}
#| label: figure-participants-eu-grouped

dorl <- cartogram_dorling(
  map_teams_eu_grouped, weight = "n_participants",
  k = 4, m_weight = 1, itermax = 1000
  )

# establish colour scale by continent
# credits: https://www.alamy.com/world-continents-infographics-colors-vector-image346678213.html and https://www.color-hex.com/color-palette/31114
col_continents <- c("#524595", "#0392cf", "#e86af0", "#ffbf00", "#95CA3E", "#F26923")
names(col_continents) <- sort(unique(map_teams$continent))

p_world <- ggplot() + 
  # World basemap
  geom_sf(
    filter(world, admin != "Antarctica"), mapping = aes(geometry = geometry),
    fill = col_paris[2], colour = "white", alpha = 0.8) +
  # team sizes
  geom_sf_interactive(
    dorl, mapping = aes(geometry = geometry, fill = continent,
                        tooltip = paste0(country_long, ": ", n_participants)),
    color = alpha("white",0.2)
    ) +
  scale_fill_manual(values = alpha(col_continents, 0.8)) +
  theme_void() +
  theme(panel.background = element_rect(fill = "transparent", color = NA),
        plot.background = element_rect(fill = "transparent", color = NA),
        legend.position = "none")

girafe(ggobj = p_world,
       width_svg = 200, height_svg = 200) |> 
  girafe_options(
    opts_tooltip(
      use_fill = FALSE,
      css = "color:black;"
    ),
    opts_sizing(rescale = TRUE)
  )
```

#### Europe

```{r}
#| label: figure-participants-eu-only

dorl <- map_teams |> 
  filter(continent == "Europe") |> 
  # this is important to remove "territories" not on the main continent (except GB and IRL)
  st_crop(xmin = -800000, xmax = 3500000, ymin = 3100000, ymax = 7343000) |> 
  cartogram_dorling(
    weight = "n_participants",
    k = 2, m_weight = 1, itermax = 1000
  )


# crop basic map first
p_eu <- world |> 
  filter(continent == "Europe") |> 
  st_crop(xmin = -800000, xmax = 3500000, ymin = 3100000, ymax = 7343000) |>
  ggplot() +
  geom_sf(mapping = aes(geometry = geometry), fill = col_paris[2], colour = "white", alpha = 0.8) +
  # team sizes
  geom_sf_interactive(
    dorl, mapping = aes(geometry = geometry, fill = continent,
                        tooltip = paste0(country_long, ": ", n_participants)),
    color = alpha("white", 0.2)
    ) +
  scale_fill_manual(values = alpha(col_continents, 0.8)) +
  theme_void() +
  theme(panel.background = element_rect(fill = "transparent", color = NA),
        plot.background = element_rect(fill = "transparent", color = NA),
        legend.position = "none")

girafe(ggobj = p_eu,
       width_svg = 80) |> 
  girafe_options(
    opts_tooltip(
      use_fill = FALSE,
      css = "color:black;"
    )
  )
```



## COL: Nations summaries {width="33%"}

### ROW: Nations table (medals)

```{r}
#| label: helper-countries-with-flags

# I want to avoid NAs for countries which do not have a flag (provided by `fmt_flag()`)
# Therefore, a vector of 2-letter country codes included in `fmt_flag()` is needed

# store the gt temporarily
tmp <- info_flags()
# extract country codes
ccodes <- tmp[["_data"]][["country_code_2"]]
# delete the gt
remove(tmp)
```

<!-- Total counts? I.e, team of four contirbutes four medals even if it was a single medal ceremony.  -->

```{r}
#| label: table-nations-ranking

# Try two column combinations to merge per-country medal counts with two-letter country codes
# This increases the number of countries covered
tab_nations <- nations_dat |> 
  left_join(select(world, iso_a2, iso_a3, name_long), by = c("country_code" = "iso_a3"))

tab_nations <- tab_nations |> 
  left_join(select(world, iso_a2, name_long), by = c("country_long" = "name_long"), suffix = c("", "_alt"))

# Use coalesce to fill in missing values from the second join
tab_nations <- tab_nations |> 
  mutate(
    iso_a2 = coalesce(iso_a2, iso_a2_alt)
  ) |> 
  select(-iso_a2_alt, -geometry_alt)

tab_nations <- tab_nations |> 
  # a handful however still require a manual fix
  mutate(iso_a2 = case_when(
    country_code == "IRI" ~ "IR",
    country_code == "TPE" ~ "TW", # this is Taiwan - are they indeed synonyms?
    country_code == "HKG" ~ "HK",
    country_code == "DMA" ~ "DO", # Dominica = DOminican Republic?
    country == "France" ~ "FR",
    country == "Norway" ~ "NO",
    country == "Kosovo" ~ NA, # (KV returns "invalid")
    TRUE ~ iso_a2
  ))

tab_nations |> 
# ranking is only present as a column index (row name)
  mutate(ranking = as.numeric(rownames(nations_dat)),
        flag = ifelse(iso_a2 %in% ccodes, iso_a2, NA)) |> 
  select(ranking, flag, iso_a2, country_code, country_long, contains("Medal"), Total) |> 
  gt() |> 
  # add country flags
  fmt_flag(columns = iso_a2) |> 
  # this way, `NA` is not shown if country's flag is missing
  text_transform(
    locations = cells_body(columns = iso_a2),
    fn = function(x) {
      ifelse(is.na(x), "", x)
    }
  ) |> 
  cols_hide(columns = "flag") |> 
  # "string" column names
  cols_label(
    ranking = "Rank", 
    iso_a2 = "", 
    country_code = "", 
    country_long = "Country",
    `Gold.Medal` = html(as.character(icon_style(fontawesome("medal"), scale = 1.75, fill = col_medals["Gold"]))),
    `Silver.Medal` = html(as.character(icon_style(fontawesome("medal"), scale = 1.75, fill = col_medals["Silver"]))),
    `Bronze.Medal` = html(as.character(icon_style(fontawesome("medal"), scale = 1.75, fill = col_medals["Bronze"])))
  ) |> 
  # general table formating
  gt::tab_options(column_labels.font.weight = "bold",
                  column_labels.padding.horizontal = px(10),
                  table.background.color = "transparent",
                  table.font.color = "grey50") |> 
  cols_align(align = "center", columns = !contains("Country")) |> 
  # realtive column widths
  cols_width(
    ranking ~ px(90),
    iso_a2 ~ px(45),
    country_code ~ px(75),
    country_long ~ px(200),
    contains("Medal") ~ px(75),
    Total ~ px(75)
  ) |>
  # add interactivity
  opt_interactive(
    use_pagination = T, use_page_size_select = T, page_size_default = 10,
    use_sorting = T,
    use_search = T,
  )
```

### ROW: Development in time (gganimate)
<!-- Aim: gganimate for daily development in medal counts for top ten nations -->

{.tabset}

#### Top 10 nations
```{r}
# which are top ten nations?
top_nations <- nations_dat[1:10, ]$country

# colour scale for countries
col_countries <- c(
  "#FFCD00", "red", "#0055A4", "#000000",
  "#CF142B", "#008C45", "grey70", "#0047A0",
  "#FF9B00", "#0A3161"
)
names(col_countries) <- sort(top_nations)

# start & end dates
first_day <- as.Date(min(medalists_dat$medal_date))
last_day <- as.Date(max(medalists_dat$medal_date))

# cumulative sums per nation
daily_medals_totals <- medalists_dat |> 
  filter(country %in% top_nations) |> 
  # input are data for individual atheletes & team medals must thus be kept only once
  select(country, medal_date, event) |> 
  distinct() |> 
  group_by(country, medal_date) |> 
  summarise(daily_medals = n(), .groups = "drop") |> 
  mutate(medal_date = as.Date(medal_date)) |> 
  # fill any missing data -> line for all countries, even for initial zero counts
  complete(medal_date = seq(first_day, last_day, by = "1 day"),
           country = unique(country),
           fill = list(daily_medals = 0)) |> 
  arrange(medal_date) |> 
  group_by(country) |> 
  mutate(cumsum_medals = cumsum(daily_medals)) |> 
  ungroup()

# the last row for each state is the total -> annotation placement
medal_sums <- daily_medals_totals |> 
  group_by(country) |> 
  slice_tail()

# plot; credits: https://github.com/z3tt/TidyTuesday/blob/main/R/2020_52_BigMacIndex.Rmd
p_cum_medals <- ggplot(daily_medals_totals, aes(x = medal_date, y = cumsum_medals, group = country, colour = country)) +
  geom_line(linewidth = 1) +
  geom_text_repel(
    data = medal_sums,
    aes(color = country, label = country),
    size = 2.5,
    direction = "y",
    xlim = c(last_day, NA),
    hjust = 0,
    segment.size = 0.75,
    segment.linetype = "dotted",
    box.padding = .4,
    segment.curvature = -0.1,
    segment.ncp = 3,
    segment.angle = 20
  ) +
  scale_x_date(breaks = seq(first_day, last_day, 1), date_labels = "%m-%d",
               expand = c(0, 0), limits = as.Date(c(first_day, "2024-08-14"))) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 105)) +
  scale_colour_manual(values = col_countries) +
  labs(
    x = "",
    y = "cumulative count"
  ) +
  theme_classic() +
  theme(
    panel.background = element_blank(),
    panel.grid = element_blank(),
    axis.text.x = element_text(angle = 90, vjust = 0.5),
    legend.position = "none",
    aspect.ratio = 0.65
  )

# animate it!
anim_cum_medals <- p_cum_medals +
  transition_reveal(along = medal_date)

animate(anim_cum_medals, nframes = 25, duration = 25, end_pause = 10)
```


#### Czech Republic

```{r}
# get cumulative sums
daily_medals_cze <- medalists_dat |> 
  filter(country == "Czechia") |> 
  select(country, medal_date, event) |> 
  # team medals should be kept only once
  distinct() |> 
  group_by(country, medal_date) |> 
  summarise(daily_medals = n(), .groups = "drop") |> 
  mutate(medal_date = as.Date(medal_date)) |> 
  complete(medal_date = seq(first_day, last_day, by = "1 day"),
           country = "Czechia",
           fill = list(daily_medals = 0)) |> 
  arrange(medal_date) |> 
  mutate(cumsum_medals = cumsum(daily_medals))

# collect medal events
events_cze <- medalists_dat |> 
  filter(country == "Czechia") |> 
  select(medal_date, discipline, event) |> 
  # team medals should be kept only once
  distinct()

# plot; credits: https://github.com/z3tt/TidyTuesday/blob/main/R/2020_52_BigMacIndex.Rmd
p_cum_medals_cze <- ggplot(daily_medals_cze, aes(x = medal_date, y = cumsum_medals, group = country)) +
  geom_line(linewidth = 1, colour = col_paris[3]) +
  scale_x_date(breaks = seq(first_day, last_day, 1), date_labels = "%m-%d",
               expand = c(0, 0), limits = as.Date(c(first_day, "2024-08-14"))) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 6), breaks = seq(0, 6, 2)) +
  scale_colour_manual(values = col_countries) +
  labs(
    x = "",
    y = "cumulative count"
  ) +
  theme_classic() +
  theme(
    panel.background = element_blank(),
    panel.grid = element_blank(),
    axis.text.x = element_text(angle = 90, vjust = 0.5),
    legend.position = "none",
    aspect.ratio = 0.65
  )

# animate it!
anim_cum_medals_cze <- p_cum_medals_cze +
  transition_reveal(along = medal_date)

animate(anim_cum_medals_cze, nframes = 25, duration = 25, end_pause = 10)
```


<!-- Birth country vs nationality: sankey? -->
```{r}
athletes_nat <- athletes_dat |> 
  select(birth_country, nationality)

# only flows with more than a single observation will be coloured somehow
athlete_transfers <- athletes_nat |> 
  filter(nchar(birth_country) > 0, birth_country != nationality) |> 
  # Freq are counts for each known combination
  group_by(birth_country, nationality) |> 
  summarise(Freq = n()) |> 
  ungroup() |> 
  mutate(group = case_when(
    Freq <= 2 ~ "max. 2 athletes",
    Freq > 2 & Freq < 6 ~ "3 - 5 athletes",
    TRUE ~ paste(birth_country, nationality, sep = " \U2192 ")
  )) |> 
  mutate(group_label = case_when(
    grepl("\U2192", group) ~ group,
    TRUE ~ NA
  )) |> 
  # sorts the data by Freq
  arrange(desc(Freq)) |> 
  mutate(
    birth_country = factor(birth_country, levels = unique(birth_country)),
    nationality = factor(nationality, levels = unique(nationality))
  )

# add more colors to this palette :
col_transfers <- c(colorRampPalette(col_paris[c(3, 1, 2)])(20), "grey30", "grey80")
names(col_transfers) <- unique(athlete_transfers$group)

### Plot
# major flows
p_transfers <- ggplot(athlete_transfers, aes(y = Freq, axis1 = birth_country, axis2 = nationality, fill = group)) +
  geom_alluvium(alpha = 0.8) +
  scale_fill_manual(values = col_transfers) +
  theme_void() +
  theme(margin(0, 50, 0, 0, unit = "pt"),
        legend.position = "none")

# create only legend
showtext::showtext_auto()
dummy_plot <- ggplot(data.frame(
  "Category" = factor(names(col_transfers), levels = names(col_transfers)),
  "Value" = 1:length(col_transfers)
  ), aes(x = Value, fill = Category)) +
  geom_bar() +
  scale_fill_manual(values = col_transfers, name = "Transfers") +
  theme_void() +
  theme(legend.position = "right")

extract_legend <- function(plot) {
  g <- ggplotGrob(plot)
  legend <- g$grobs[which(sapply(g$grobs, function(x) x$name) == "guide-box")][[1]]
  return(legend)
}

# Extract the legend
legend_grob <- extract_legend(dummy_plot)
  
# combine
grid.arrange(p_transfers, legend_grob, ncol = 2, widths = c(2.5, 4.5))
```

